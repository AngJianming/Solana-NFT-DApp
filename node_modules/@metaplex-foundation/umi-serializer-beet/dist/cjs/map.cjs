'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var umi = require('@metaplex-foundation/umi');
var errors = require('./errors.cjs');
var getResolvedSize = require('./getResolvedSize.cjs');
var getSizeDescription = require('./getSizeDescription.cjs');
var getSizeFromChildren = require('./getSizeFromChildren.cjs');
var getSizePrefix = require('./getSizePrefix.cjs');
var numbers = require('./numbers.cjs');

function map(key, value, options = {}) {
  const size = options.size ?? numbers.u32();
  if (size === 'remainder' && (key.fixedSize === null || value.fixedSize === null)) {
    throw new errors.BeetSerializerError('Serializers of "remainder" size must have fixed-size items.');
  }
  return {
    description: options.description ?? `map(${key.description}, ${value.description}; ${getSizeDescription.getSizeDescription(size)})`,
    fixedSize: getSizeFromChildren.getSizeFromChildren(size, [key.fixedSize, value.fixedSize]),
    maxSize: getSizeFromChildren.getSizeFromChildren(size, [key.maxSize, value.maxSize]),
    serialize: map => {
      if (typeof size === 'number' && map.size !== size) {
        throw new errors.BeetSerializerError(`Expected map to have ${size} items but got ${map.size}.`);
      }
      const itemBytes = Array.from(map, ([k, v]) => umi.mergeBytes([key.serialize(k), value.serialize(v)]));
      return umi.mergeBytes([getSizePrefix.getSizePrefix(size, map.size), ...itemBytes]);
    },
    deserialize: (bytes, offset = 0) => {
      const map = new Map();
      if (typeof size === 'object' && bytes.slice(offset).length === 0) {
        throw new errors.DeserializingEmptyBufferError('map', new Map());
      }
      const [resolvedSize, newOffset] = getResolvedSize.getResolvedSize(size, [key.fixedSize, value.fixedSize], bytes, offset);
      offset = newOffset;
      for (let i = 0; i < resolvedSize; i += 1) {
        const [deserializedKey, kOffset] = key.deserialize(bytes, offset);
        offset = kOffset;
        const [deserializedValue, vOffset] = value.deserialize(bytes, offset);
        offset = vOffset;
        map.set(deserializedKey, deserializedValue);
      }
      return [map, offset];
    }
  };
}

exports.map = map;
//# sourceMappingURL=map.cjs.map
