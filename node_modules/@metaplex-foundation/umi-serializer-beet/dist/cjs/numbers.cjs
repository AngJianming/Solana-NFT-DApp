'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var beet = require('@metaplex-foundation/beet');
var umi = require('@metaplex-foundation/umi');
var buffer = require('buffer');
var errors = require('./errors.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

// Helpers.
const wrapBeet = fixedBeet => (options = {}) => {
  const isBigEndian = options.endian === umi.Endian.Big;
  let defaultDescription = fixedBeet.description;
  if (fixedBeet.byteSize > 1) {
    defaultDescription += isBigEndian ? '(be)' : '(le)';
  }
  const serializer = {
    description: options.description ?? defaultDescription,
    fixedSize: fixedBeet.byteSize,
    maxSize: fixedBeet.byteSize,
    serialize: value => {
      const buffer$1 = buffer.Buffer.alloc(fixedBeet.byteSize);
      fixedBeet.write(buffer$1, 0, value);
      return new Uint8Array(buffer$1);
    },
    deserialize: (bytes, offset = 0) => {
      if (bytes.slice(offset).length === 0) {
        throw new errors.DeserializingEmptyBufferError(fixedBeet.description);
      }
      const buffer$1 = buffer.Buffer.from(bytes);
      const value = fixedBeet.read(buffer$1, offset);
      return [value, offset + fixedBeet.byteSize];
    }
  };
  return isBigEndian ? umi.reverseSerializer(serializer) : serializer;
};
const wrapBigintBeet = fixedBeet => (options = {}) => {
  const isBigEndian = options.endian === umi.Endian.Big;
  const serializer = {
    description: options.description ?? fixedBeet.description + (isBigEndian ? '(be)' : '(le)'),
    fixedSize: fixedBeet.byteSize,
    maxSize: fixedBeet.byteSize,
    serialize: value => {
      const buffer$1 = buffer.Buffer.alloc(fixedBeet.byteSize);
      fixedBeet.write(buffer$1, 0, value);
      return new Uint8Array(buffer$1);
    },
    deserialize: (bytes, offset = 0) => {
      if (bytes.slice(offset).length === 0) {
        throw new errors.DeserializingEmptyBufferError(fixedBeet.description);
      }
      const buffer$1 = buffer.Buffer.from(bytes);
      const rawValue = fixedBeet.read(buffer$1, offset);
      const value = BigInt(typeof rawValue === 'number' ? rawValue : rawValue.toString());
      return [value, offset + fixedBeet.byteSize];
    }
  };
  return isBigEndian ? umi.reverseSerializer(serializer) : serializer;
};

// Simple numbers.
const u8 = wrapBeet(beet__namespace.u8);
const u16 = wrapBeet(beet__namespace.u16);
const u32 = wrapBeet(beet__namespace.u32);
const i8 = wrapBeet(beet__namespace.i8);
const i16 = wrapBeet(beet__namespace.i16);
const i32 = wrapBeet(beet__namespace.i32);

/**
 * Same as u16, but serialized with 1 to 3 bytes.
 *
 * If the value is above 0x7f, the top bit is set and the remaining
 * value is stored in the next bytes. Each byte follows the same
 * pattern until the 3rd byte. The 3rd byte, if needed, uses
 * all 8 bits to store the last byte of the original value.
 */
/* eslint-disable no-bitwise */
function shortU16() {
  return {
    description: 'shortU16',
    fixedSize: null,
    maxSize: 3,
    serialize: value => {
      if (value < 0 || value > 65535) {
        throw new RangeError(`Only values in the range [0, 65535] can be serialized to shortU16. \`${value}\` given.`);
      }
      const bytes = [0];
      for (let ii = 0;; ii += 1) {
        // Shift the bits of the value over such that the next 7 bits are at the right edge.

        const alignedValue = value >> ii * 7;
        if (alignedValue === 0) {
          // No more bits to consume.
          break;
        }
        // Extract those 7 bits using a mask.
        const nextSevenBits = 0b1111111 & alignedValue;
        bytes[ii] = nextSevenBits;
        if (ii > 0) {
          // Set the continuation bit of the previous slice.
          bytes[ii - 1] |= 0b10000000;
        }
      }
      return new Uint8Array(bytes);
    },
    deserialize: (bytes, offset = 0) => {
      let value = 0;
      let byteCount = 0;
      while (++byteCount // eslint-disable-line no-plusplus
      ) {
        const byteIndex = byteCount - 1;
        const currentByte = bytes[offset + byteIndex];
        const nextSevenBits = 0b1111111 & currentByte;
        // Insert the next group of seven bits into the correct slot of the output value.
        value |= nextSevenBits << byteIndex * 7;
        if ((currentByte & 0b10000000) === 0) {
          // This byte does not have its continuation bit set. We're done.
          break;
        }
      }
      return [value, offset + byteCount];
    }
  };
}
/* eslint-enable no-bitwise */

// Big numbers.
const u64 = (options = {}) => {
  const serializer = wrapBigintBeet(beet__namespace.u64)(options);
  return {
    ...serializer,
    serialize: value => {
      if (value < 0) throw new RangeError('u64 cannot be negative');
      return serializer.serialize(value);
    }
  };
};
const u128 = (options = {}) => {
  const serializer = wrapBigintBeet(beet__namespace.u128)(options);
  return {
    ...serializer,
    serialize: value => {
      if (value < 0) throw new RangeError('u128 cannot be negative');
      return serializer.serialize(value);
    }
  };
};
const i64 = (options = {}) => {
  const serializer = wrapBigintBeet(beet__namespace.i64)(options);
  return {
    ...serializer,
    serialize: value => {
      if (value < (-2n) ** 63n) {
        throw new RangeError('i64 cannot be lower than -2^63');
      }
      if (value > 2n ** 63n - 1n) {
        throw new RangeError('i64 cannot be greater than 2^63 - 1');
      }
      return serializer.serialize(value);
    }
  };
};
const i128 = (options = {}) => {
  const serializer = wrapBigintBeet(beet__namespace.i128)(options);
  return {
    ...serializer,
    serialize: value => {
      if (value < (-2n) ** 127n) {
        throw new RangeError('i128 cannot be lower than -2^127');
      }
      if (value > 2n ** 127n - 1n) {
        throw new RangeError('i128 cannot be greater than 2^127 - 1');
      }
      return serializer.serialize(value);
    }
  };
};
const f32 = () => ({
  description: 'f32 [not supported]',
  fixedSize: 4,
  maxSize: 4,
  serialize: () => {
    throw new errors.OperationNotSupportedError('f32');
  },
  deserialize: () => {
    throw new errors.OperationNotSupportedError('f32');
  }
});
const f64 = () => ({
  description: 'f64 [not supported]',
  fixedSize: 8,
  maxSize: 8,
  serialize: () => {
    throw new errors.OperationNotSupportedError('f64');
  },
  deserialize: () => {
    throw new errors.OperationNotSupportedError('f64');
  }
});

exports.f32 = f32;
exports.f64 = f64;
exports.i128 = i128;
exports.i16 = i16;
exports.i32 = i32;
exports.i64 = i64;
exports.i8 = i8;
exports.shortU16 = shortU16;
exports.u128 = u128;
exports.u16 = u16;
exports.u32 = u32;
exports.u64 = u64;
exports.u8 = u8;
//# sourceMappingURL=numbers.cjs.map
